# Standards Ingest Product Requirements Document (PRD)

## 1. Executive Summary

We are extending an existing code review system to support ingestion and management of multiple standards sets—collections of individual standards—for code quality checks. The system will allow users to:

1. Upload and manage **Standards Sets** and **Classifications** (metadata about technologies/languages)
2. Dynamically match code repositories against the standards relevant to the repository's technology stack
3. Provide integrated **frontend pages** and **backend API endpoints** for managing standards, classifications, and code reviews

These features build on an existing Python-based API (FastAPI) that leverages Anthropic's Claude AI model and MongoDB for persistence, and a Node.js/Hapi.js-based GOV.UK Design System (GDS)-compliant frontend.

## 2. Background

### 2.1 Existing System Overview

#### 2.1.1 Core Functionality (Current)
* **Accept Code Submissions** for review
* **Process submissions asynchronously** using AI agents
* **Check code against multiple predefined standards**
* **Store review results** in MongoDB
* **Provide RESTful API endpoints** to retrieve and manage code review results

Currently, the system is configured with a **hard-coded** set of standards.

#### 2.1.2 API Backend
* **Language/Framework**: Python, FastAPI
* **AI Model**: Anthropic's Claude for intelligent code analysis
* **Database**: MongoDB for persistence
* **Architecture**:
  * Modular structure with FastAPI's dependency injection
  * Robust logging, strict typing, and comprehensive tests
  * Enforces code quality with Pylint and Pyright

#### 2.1.3 Frontend
* **Language/Framework**: Node.js with Hapi.js
* **Design**: GOV.UK Design System (GDS) with SCSS for styling
* **Rendering**: Nunjucks templating, server-side rendering
* **Tooling**: Webpack, Babel, TypeScript, Jest, ESLint, Prettier
* **Current Features**:
  * A page for submission of code reviews
  * A page for viewing all previous code views
  * A page for viewing code view details

## 3. Problem Statement & Goals

### 3.1 Problem Statement

* Currently, the code review system only supports a single, hard-coded set of standards
* We need the ability to ingest **any** standards from remote repositories and store them in the database
* We must implement a **Classification Manager** to match code repositories with relevant standards based on technology stacks

### 3.2 Goals

1. **Flexible Standards Ingestion**: Allow users to upload new standard sets and automatically parse them into individual standards
2. **Classification-Based Matching**: Implement a classification system to label standards (e.g., "Python," "Node.js," ".NET") and automatically match code repositories to relevant standards
3. **Enhanced Reporting**: Adapt the existing code review process to incorporate multiple standard sets, each with its own custom LLM prompt
4. **Frontend Management**: Provide user interfaces to manage classifications, standards, and standard sets in alignment with GDS guidelines

## 4. High-Level Solution Overview

1. **Classification Manager**
   * Backend to manage classifications (create, list, delete)
   * Frontend pages to create/delete classifications
   * Allows grouping of technologies/languages in code repositories

2. **Standards Ingest**
   * Ingest a "standards repository" from a user-provided URL
   * Parse the repository using an LLM agent, create or replace a "standard-set," and store individual "standards" in the database
   * Each standard can be associated with zero or more classifications

3. **Updated Code Review Flow**
   * On code review submission, the system downloads the repository, merges the code, and uses an LLM to identify which classifications apply to the codebase
   * Based on the classifications that match the codebase stack, the system filters relevant standards from each selected standard set
   * The relevant standards are then passed to the reporting agent for analysis

4. **Frontend Enhancements**
   * New pages to manage standard sets and classifications
   * Modified submission page to show multiple standard sets for selection
   * Modified code review detail pages with tabs for each report by standard set

## 5. Detailed Requirements

### 5.1 Classification Manager

#### 5.1.1 Backend Requirements
1. **Database Schema**
   * New collection/table: `classifications`
   * Each `classification` record includes:
     * `_id` (automatically generated by MongoDB)
     * `name` (string, unique)

2. **API Endpoints** (`/api/v1/classifications`):
   * **POST** `/api/v1/classifications`
     * Creates a new classification in the database
     * Request Body:
       ```json
       {
         "name": "Node.js"
       }
       ```
     * Response:
       ```json
       {
         "_id": "auto-generated-id",
         "name": "Node.js"
       }
       ```
   * **GET** `/api/v1/classifications`
     * Returns all classifications in alphabetical order
   * **DELETE** `/api/v1/classifications/{id}`
     * Deletes the specified classification
     * Must also remove any references to this classification from any "standards" documents

#### 5.1.2 Frontend Requirements
1. **New Navigation Item**: "Manage Classifications"
2. **Manage Classifications Page**
   * **List** all existing classifications (table view) (calls API `GET /api/v1/classifications` on load)
   * **Add** a new classification (form that calls API `POST /api/v1/classifications`)
   * **Delete** a classification (action that calls API `DELETE /api/v1/classifications/{id}`)
   * Show a **warning** message that adding or deleting classifications requires re-ingestion of existing standard sets to update classification relationships

#### 5.1.3 Example Classifications
```
Python, C#, Node.js, JavaScript, Java, .NET
```

### 5.2 Standards Ingest

#### 5.2.1 Terminology
* **Code Repository**: The repository to be reviewed
* **Standard-Set**: A parent object that groups multiple individual standards. Contains:
  * `_id`, `name`, `repository_url`, `custom_prompt`
* **Standards**: Individual entries within a standard-set. Contains:
  * `_id`, `text`, `repository_path`, relation to `classifications`
* **Classifications**: Technology identifiers that help categorize standards (e.g., `Python`)

#### 5.2.2 Backend Requirements
1. **Database Schema**
   * **Standard-Sets** Collection
     * `_id`, `name`, `repository_url`, `custom_prompt`
   * **Standards** Collection
     * `_id`, `text`, `repository_path`, `standard_set_id`, `classifications[]`

2. **Relationships**
   * **One-to-Many**: One standard-set to many standards
   * **Many-to-Many**: Many standards to many classifications (implemented by storing classification IDs in the `classifications[]` array within the standard document)

3. **API Endpoints**
   * **`/api/v1/standard-sets`**
     * **POST** `/api/v1/standard-sets`
       1. Check if a standard-set with the same `name` exists. If so, delete the existing one and all its associated standards
       2. Create a new standard-set record
       3. Download the repository from the provided `repository_url` to a temporary folder (note that we already have a `git_repos_agent` that can download a repository)
       4. Parse each file in the repository using an LLM agent
       5. For each discovered standard (could be multiple standards within a file), create a new record in the `standards` collection, associating it with the newly created standard-set
         * Determine relevant classifications from the text (using LLM or other rules)
         * If no classifications apply, the standard is universal
       6. Cleanup temporary folder
       7. Return newly created standard-set with its `_id`
     * **GET** `/api/v1/standard-sets`
       * Returns a list of standard-set objects (without their associated standards)
     * **GET** `/api/v1/standard-sets/{id}`
       * Returns one standard-set object including an array of all associated standards
     * **DELETE** `/api/v1/standard-sets/{id}`
       * Deletes the standard-set and all associated standards (and their references to classifications)

### 5.3 Updated Code Review Flow

#### 5.3.1 Required Changes to Existing `/api/v1/code-reviews` Endpoint

1. **Request Payload**
   * Must now include an array of standard-set IDs to specify which sets to check against
   ```json
   {
     "repository_url": "https://github.com/DEFRA/find-ffa-data-ingester",
     "standard_sets": ["xyz123", "abc123"]
   }
   ```

2. **Processing**
   1. Download and merge the code repository (existing functionality)
   2. Use a new "Standards Selection" LLM agent to determine which classifications match the codebase
      * Output (example):
      ```json
      {
        "Python": false,
        "C#": false,
        "Node.js": true,
        "JavaScript": true,
        "Java": false,
        ".NET": false
      }
      ```
   3. For each `standard_set_id` in `standard_sets`, **query** for all standards in that set whose classifications array is either empty (universal) or is a subset of the `true` classifications from step 2
   4. Combine these relevant standards with the code repository's merged file and pass them to the existing reporting agent
   5. Use the `custom_prompt` from the standard-set for the LLM prompt
   6. Save a separate Markdown report file per standard-set in the format:
      ```
      {code-review-record-id}-{standard-set-name}.md
      ```
   7. Store references to these new report files in the `code-reviews` record

3. **Response & Storage**
   * When the code review is complete, the `GET /api/v1/code-reviews/{id}` endpoint should provide:
     * The array of associated standard-sets used in the review
     * The Markdown reports generated for each standard-set (filename and content)

#### 5.3.2 Existing Functionality to Remove
* **Remove** hard-coded standards download in the code review flow. Standards are now **persisted** in the database

## 6. Frontend Requirements

### 6.1 Navigation
* **Manage standards**:  New item linking to `/standards`

### 6.1 Standards Landing Page
* A standards landing page that contains links to: 
* ** Manage classifications**: text linking to `/standards/classifications`
* **Manage standards**: text linking to `/standards/standard-sets`

### 6.2 Classification Manager Pages
* **Manage Classifications Page (`/standards/classifications`)**
  * Display a **table** of all classifications - calls API`GET /api/v1/classifications`
  * **Delete Classification** button for each row of the table - calls API DELETE to `/api/v1/classifications/{id}`
  * **Add Classification** form - calls API POST to `/api/v1/classifications`
  * Display **warning** about re-ingestion for changes in classifications

### 6.3 Standards Sets Management

1. **Manage Standards Page (`/standards/standard-sets`)**
   * Display a **table** of all standard-sets (calls API `GET /api/v1/standard-sets`)
     * Columns: Standard-Set Name, Repository URL (opens in new tab), Delete button
     * **Delete** calls API `DELETE /api/v1/standard-sets/{id}`
   * **Add New Standard-Set** button -> `/standards/standard-sets/new`

2. **Add New Standard-Set Page (`/standards/standard-sets/new`)**
   * Form fields: `name`, `repository_url`, `custom_prompt`
   * On submit, calls API  `POST /api/v1/standard-sets`
   * If success, **redirect** to `/standards/standard-sets/{id}` (the standards detail page)

3. **Standard Set Detail Page (`/standards/standard-sets/{id}`)**
   * Call API **GET** `/api/v1/standard-sets/{id}` on page load
   * Show:
     * Standard-Set Name
     * Repository URL (open in new tab)
     * **Custom Prompt** (hide behind a GDS accordion)
   * **Table** of associated standards, read-only:
     * Columns:
       * Standard Text
       * Comma-separated list of classifications
       * Repository Path (opens in new tab if relevant)
       * Classifications 

### 6.4 Standards Submission Updates
* **Standard-Sets Checkbox List**
  * The values are dynamically generated, using the fetched from `GET /api/v1/standard-sets`
  * The user can select one or more sets to include in their code review request
  * The form then sends an array of standard-set IDs with `repository_url` to API `POST /api/v1/code-reviews`
  * Add a 'check all' link that checks all the standard-sets to be included in the code review

### 6.5 Code Review Record Detail Page Updates
* **Reports Array**
  * Each code review can now have multiple standard-set reports
  * Populate the existing **tabbed interface** dynamically using the new `standard_sets array` from the existing API `GET /api/v1/code-reviews/${id}`
  * Each tab title corresponds to the standard-set name
  * The content of the tab shows the Markdown reports generated for the corresponding each standard-set

## 7. Data Model & ER Diagram (Conceptual)

```
┌───────────────────┐          ┌────────────────────┐
│    standard-sets  │          │      standards     │
│  _id              │◄──┐ 1..* │  _id               │
│  name             │   │      │  text              │
│  repository_url   │   │      │  repository_path   │
│  custom_prompt    │   │      │  standard_set_id   │
└───────────────────┘   │      │  classification_ids[]         │
                        │      └────────────────────┘
                        │
                        │1..* (a standard-set can have many standards)
                        │
┌───────────────────┐   │
│       classifications        │   │
│  _id              │   │
│  name             │◄──┘M..N (a standard can have many classifications)
└───────────────────┘
```

## 8. Database Schema for Classificationging System Using References

To implement the classificationging system with references in MongoDB, we'll establish a many-to-many relationship between standards and classifications. This approach ensures data normalization and efficient querying.

### 8.1 Collections Overview

The system consists of two main collections:

- **Classifications Collection:** Stores individual classifications.
- **Standards Collection:** Stores individual standards, each containing references to associated classifications.

### 8.2 Classifications Collection Schema

Each document in the `classifications` collection represents a unique classification with the following fields:

```json
{
    "_id": ObjectId,    // Unique identifier for the classification
    "name": String      // Name of the classification (e.g., "Python", "Node.js")
}
```

### 8.3 Standards Collection Schema

Each document in the `standards` collection represents an individual standard and includes references to associated classifications:

```json
{
    "_id": ObjectId,            // Unique identifier for the standard
    "text": String,            // Content of the standard
    "repository_path": String,  // Path to the standard in the repository
    "standard_set_id": ObjectId, // Reference to the associated standard-set
    "classification_ids": [ObjectId, ...]  // Array of ObjectId references to associated classifications
}
```

### 8.4 Indexing Strategy

To optimize query performance, especially for operations involving classification associations, implement the following indexes:

#### Classifications Collection

```json
{ "name": 1 }
```

This index ensures efficient retrieval of classifications by name and enforces uniqueness if required.

#### Standards Collection

```json
{ "standard_set_id": 1 }
```

This index facilitates quick access to standards within a specific standard set.

```json
{ "classification_ids": 1 }
```

This index enables efficient querying of standards associated with specific classifications.

### 8.5 Handling Classification Deletions

If a user deletes a classification, it must be removed from each standard that references the classification. The system should handle this dynamically by:

1. Removing the classification's ID from the `classification_ids` array in all affected standards in the `standards` collection.
2. Ensuring that standards with no remaining classifications are correctly handled as universal (if applicable) or flagged for further review.
3. Logging the deletion operation for auditing purposes.

### 8.6 Example Documents

#### Classifications Collection Document

```json
{
    "_id": ObjectId("60c72b2f9af1f8b5d1c8d1e1"),
    "name": "Python"
}
```

#### Standards Collection Document

```json
{
    "_id": ObjectId("60c72b3f9af1f8b5d1c8d1e2"),
    "text": "Standard content here...",
    "repository_path": "/path/to/standard",
    "standard_set_id": ObjectId("60c72b4f9af1f8b5d1c8d1e3"),
    "classification_ids": [
        ObjectId("60c72b2f9af1f8b5d1c8d1e1"),
        ObjectId("60c72b2f9af1f8b5d1c8d1e4")
    ]
}
```

### 8.7 Classification Deletion Workflow Example

1. **Classification Deletion Request:** A user issues a DELETE request for a classification (e.g., `Python`) via the `/api/v1/classifications/{id}` endpoint.
    
2. **Database Update:** The system performs the following operations:
    
    - Query the `standards` collection for documents containing the classification's `_id` in their `classification_ids` array.
    - Remove the classification's `_id` from the `classification_ids` array of all matching standards.
    - Save the updated standards back to the database.
3. **Validation and Logging:**
    
    - Ensure no standards are left with inconsistent `classification_ids` arrays.
    - Log the operation, including the ID of the deleted classification and the affected standards.
4. **User Notification:**
    
    - Notify the user if any standards were affected by the deletion, and if necessary, recommend re-ingesting related standard sets to ensure consistency.

This workflow ensures that classification deletions are consistently propagated through the system, maintaining data integrity and alignment with operational requirements.